## 第二章 Linux GDB调试指南

#### 2.1 准备

生成带调试信息的程序：

gcc -g -o hello_server hello

-g选项实际上同样也适用于使用makefile、cmake等工具编译生成的Linux程序。还可以采用-O0关闭编译器优化。

启动调试：

1. gdb filename：调试目标程序。
2. gdb attach pid：调试已经启动的程序。
3. gdb filename corename：调试core文件。

> ps: ulimit -c unlimited 打开core文件生成。

#### 2.2 常用命令

run    r    运行一个程序
continue    c    让暂停的程序继续运行
break    b    添加断点
tbreak    tb    添加临时断点
backtrace    bt    查看当前线程的调用堆栈
frame    f    切换到当前调用线程的指定堆栈
info    info    查看断点/线程等信息
enable    enable    启用某个断点
disable    disable    禁用某个断点
delete    del    删除断点
list    l    显示源码
print    p    打印或修改变量或寄存器值
ptype    ptype    查看变量类型
thread    thread    切换到指定线程
next    n    运行到下一行
step    s    如果有调用函数，进入调用的函数内部，相当于step into
until    u    运行到指定行停下来
finish    fi    结束当前调用函数，到上一层函数调用处
return    return    结束当前调用函数并返回指定值，到上一层函数调用处
jump    j    将当前程序执行流跳转到指定行或地址
disassemble    dis    查看汇编代码
set args        设置程序启动命令行参数
show args        查看设置的命令行参数
watch    watch    监视某一个变量或内存地址的值是否发生变化
display    display    监视的变量或者内存地址，当程序中断后自动输出监控的变量或内存地址

#### 2.3 调试多线程

1. gdb将程序跑起来，Ctrl+c中断，info threads查看当前线程数。
2. thread 线程编号切换到对应线程，bt查看当前线程的函数调用栈。
3. 源码中找到创建各个线程的函数，b 函数名打断点后，分析执行逻辑。

set scheduler-locking on/step/off：可以锁定/释放/单步调试当前线程。

#### 2.4 高级技巧

break [lineNo] if [condition]，其中lineNo是程序触发断点后需要停的位置，condition是断点触发的条件。

图形化界面：gdbtui -q 需要调试的程序名/ctrl+x+a。

layout + 窗口类型命令来进行选择自己需要的窗口。

Ctrl + n/ctrl + p吊坠窗口焦点。

## 第4章 网络编程重难点

#### 4.1 socket编程

socket编写简单的服务器

```
#include <arpa/inet.h>
#include <netinet/in.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <unistd.h>

#include <iostream>
#include <vector>

int main()
{
    // 1.创建一个监听socket
    int listenFd = socket(AF_INET, SOCK_STREAM, 0);
    if (listenFd == -1)
    {
        std::cout << "create listen socket fail" << std::endl;
        return -1;
    }
    // 2. 初始化服务器地址并绑定到socket
    struct sockaddr_in serverAddr;
    serverAddr.sin_family      = AF_INET;
    serverAddr.sin_port        = htons(8000);
    serverAddr.sin_addr.s_addr = inet_addr("127.0.0.1");
    if (bind(listenFd, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) == -1)
    {
        std::cout << "bind socket fail" << std::endl;
        close(listenFd);
        return -1;
    }
    // 3. 开启监听
    if (listen(listenFd, SOMAXCONN) == -1)
    {
        std::cout << "listen error" << std::endl;
        close(listenFd);
        return -1;
    }
    // 4. 接受客户端连接
    while (true)
    {
        struct sockaddr_in clientAddr;
        socklen_t clientAddrLen = sizeof(clientAddr);
        int clientFd            = accept(listenFd, (struct sockaddr*)&clientAddr, &clientAddrLen);
        if (clientFd != -1)
        {
            // 5. 接受数据
            char recvBuf[32] = {0}; // 假定最大32字节
            int ret          = recv(clientFd, recvBuf, 32, 0);
            if (ret > 0)
            {
                // 6. 处理数据
                ret = send(clientFd, recvBuf, strlen(recvBuf), 0);
                if (ret != strlen(recvBuf))
                    std::cout << "send data error." << std::endl;
                else
                    std::cout << "send data to client successfully, data: " << recvBuf << std::endl;
            }
            else
            {
                std::cout << "recv data error." << std::endl;
            }
        }
    }
    // 7. 关闭连接
    close(listenFd);
    return 0;
}
```

简单的客户端

```
#include <arpa/inet.h>
#include <netinet/in.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <unistd.h>

#include <iostream>
#include <vector>

#define SEND_DATA "helloworld"
#define SERVER_ADDRESS "127.0.0.1"
#define SERVER_PORT 3000

int main()
{
    // 1.创建一个socket
    int clientFd = socket(AF_INET, SOCK_STREAM, 0);
    if (clientFd == -1)
    {
        std::cout << "create socket fail" << std::endl;
        return -1;
    }
    // 2. 初始化地址并连接服务器
    struct sockaddr_in serverAddr;
    serverAddr.sin_family      = AF_INET;
    serverAddr.sin_port        = htons(SERVER_PORT);
    serverAddr.sin_addr.s_addr = inet_addr(SERVER_ADDRESS);
    if (connect(clientFd, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) == -1)
    {
        std::cout << "connet server fail" << std::endl;
        close(clientFd);
        return -1;
    }

    // 3. 向服务器发送数据
    int ret = send(clientFd, SEND_DATA, strlen(SEND_DATA), 0);
    if (ret != strlen(SEND_DATA))
    {
        std::cout << "send data error" << std::endl;
        close(clientFd);
        return -1;
    }
    std::cout << "send data successfully." << std::endl;

    // 4. 从客户端收取数据
    char recvBuf[32] = {0};
    ret = recv(clientFd, recvBuf, 32, 0);
    if (ret > 0)
    {
        std::cout << "recv data successfully, data: " << recvBuf << std::endl;
    }
    else
    {
        std::cout << "recv data error, data: " << recvBuf << std::endl;
    }
    // 5. 关闭连接
    close(clientFd);
    return 0;
}
```

#### 4.2 IO多路复用

select：检测一组socket中是否有“事件”就绪。

读事件就绪：

> socket 内核中，接收缓冲区中的字节数大于等于低水位标记 SO_RCVLOWAT，此时调用 recv 或 read 函数可以无阻塞的读该文件描述符， 并且返回值大于 0；
TCP 连接的对端关闭连接，此时调用 recv 或 read 函数对该 socket 读返回 0 值 ；
侦听 socket 上有新的连接请求；
socket 上有未处理的错误。

写事件就绪：

> socket 内核中，发送缓冲区中的可用字节数(发送缓冲区的空闲位置大⼩) 大于等于低水位标记 SO_SNDLOWAT，此时可以无阻塞的写, 并且返回值大于 0；
socket 的写操作被关闭(调用了 close 或 shutdown 函数)（ 对一个写操作被关闭的 socket 进行写操作, 会触发 SIGPIPE 信号）；
> 
> socket 使⽤非阻塞 connect 连接成功或失败时。

异常事件就绪

> socket 上收到带外数据。

```c_cpp
int select(int nfds,  // 所有需要检测的fd中的最大值
		   fd_set *readfds, // 可读事件集合
           fd_set *writefds,
           fd_set *exceptfds,
           struct timeval *timeout); // 超时时间
fd_set本质是1024位的位数组,每一位表示某个fd是否就绪.

void FD_SET(int fd, fd_set *set); // 将fd加入待检测的事件集合中
void FD_CLR(int fd, fd_set *set); // 从fd_set上删除某个fd
void FD_ZERO(fd_set *set);
int  FD_ISSET(int fd, fd_set *set);
```

poll：检测一组文件描述符上的可读、可写与出错事件。

```c_cpp
int poll(struct pollfd* fds, 
        nfds_t nfds, // pollfd数组长度
        int timeout); // 超时事件，单位ms
  
struct pollfd {
    int   fd;         /* 待检测事件的 fd       */
    short events;     /* 关心的事件组合        */
    short revents;    /* 检测后实际触发的事件类型  */
};
std::vector<pollfd> fds;
int n = poll(&fds[0], fds,size(), 1000);
for(size_t i = 0; i < fds.size(); i++){
   // 事件可读
    if (fds[i].revents & POLLIN) {
      if (fds[i].fd == listenFd)
      // 为listenFd，说明新连接事件，接受新连接
      
       else {
         // 普通clientfd，接收数据
       }
    }
}
```

相比select：

- poll不再要求计算最大文件描述符。
- 基于链表存储，没有最大连接数限制。
- 调用poll时，只需要对参数进行一次设置。

epoll

```c_cpp
int epoll_create(int size);
int epoll_ctl(int epfd, int op, int fd, struct epoll_event* event);
int epoll_wait(int epfd, 
                struct epoll_event* events, 
                int maxevents, int timeout);

struct epoll_event
{
    uint32_t     events;      /* 需要检测的 fd 事件，取值与 poll 函数一样 */
    epoll_data_t data;        /* 用户自定义数据 */
};
```

触发模式：

对于水平触发模式，一个事件只要有，就会一直触发；
对于边缘触发模式，只有一个事件从无到有才会触发。

LT 模式下，读事件触发后，可以按需收取想要的字节数，不用把本次接收到的数据收取干净（即不用循环到 recv 或者 read 函数返回 -1，错误码为 EWOULDBLOCK 或 EAGAIN）；ET 模式下，读事件必须把数据收取干净，因为你不一定有下一次机会再收取数据了，即使有机会，也可能存在上次没读完的数据没有及时处理，造成客户端响应延迟。

LT 模式下，不需要写事件一定要及时移除，避免不必要的触发，浪费 CPU 资源；ET 模式下，写事件触发后，如果还需要下一次的写事件触发来驱动任务（例如发上次剩余的数据），你需要继续注册一次检测可写事件。

LT 模式和 ET 模式各有优缺点，无所谓孰优孰劣。使用 LT 模式，我们可以自由决定每次收取多少字节（对于普通 socket）或何时接收连接（对于侦听 socket），但是可能会导致多次触发；使用 ET 模式，我们必须每次都要将数据收完（对于普通 socket）或必须理解调用 accept 接收连接（对于侦听socket），其优点是触发次数少。

```c_cpp
// epoll server
while(true)
{
  epoll_event epoll_events[1024];
  int n = epoll_wait(epollfd, epoll_events, 1024, 1000);
  if (n < 0)
  {
    if (errno == EINTR)
      continue; // 信号中断
    else
      break;
  }
  else if (n == 0)
    continue;
}
for (size_t i = 0; i < n; i++)
{
  if (epoll_events[i].events & EPOLLIN)
  {
    // 处理可读事件
    
  }
  else if (epoll_events[i].events & EPOLLOUT)
  {
  		// 处理可写事件
  }
  else if (epoll_events[i].events & EPOLLERR)
  {
  		//处理出错事件
  }
}
```

一般在 fd 数量比较多，但某段时间内，就绪事件 fd 数量较少的情况下，epoll_wait 才会体现出它的优势

### 4.3 阻塞与非阻塞模式

阻塞和非阻塞模式下,connet, accept, send/write, recv/read几个函数表现会不同。

通过fcntl()函数可以将对应socket设置为非阻塞模式:

```
int oldSocketFlag = fdntl(sockfd, F_GETFL, 0);
int newSocketFlag = oldSocketFlag & O_NONBLOCK;
fcntl(sockfd, F_SETFL, newSockedFlag);
```

Linux 下的 socket() 创建函数也可以直接在创建时将 socket 设置为非阻塞模式

```
int s = socket(AF_INET, SOCK_STREAM | O_NONBLOCK, IPPROC_TCP);
```

send 函数本质上并不是往网络上发送数据，而是将应用层发送缓冲区的数据拷贝到内核缓冲区中去，至于什么时候数据会从网卡缓冲区中真正地发到网络中去要根据 TCP/IP 协议栈的行为来确定。

recv 函数本质上也并不是从网络上收取数据，而只是将内核缓冲区中的数据拷贝到应用程序的缓冲区中，当然拷贝完成以后会将内核缓冲区中该部分数据移除。

当 socket 是非阻塞模式，继续调用 send/recv 函数，send/recv 函数不会阻塞程序执行流，而是会立即出错返回，我们会得到一个相关的错误码errno，Linux 平台上该错误码为 EWOULDBLOCK 或 EAGAIN（这两个错误码值相同），Windows 平台上错误码为 WSAEWOULDBLOCK。

因此非阻塞模式下的做法：
所以，建议要么返回值 n 等于 buf_length 才认为正确，要么在一个循环中调用 send 函数，如果数据一次性发不完，记录偏移量，下一次从偏移量处接着发，直到全部发送完为止。
